e <- arima.sim(model = list(ar = 0.5), n = n, sd = sdv)
y <- mu + e
n <- 50
b <- c(1, 1, 0.1
sdv <- 1
x <- c( rep( 0, n/2 ), rep( 1, n/2 ) )
t <- 1:n
mu <- b[1] + b[2] * x + b[3] * t
e <- arima.sim(model = list(ar = 0.5), n = n, sd = sdv)
y <- mu + e
n <- 50
b <- c(1, 1, 0.1)
sdv <- 1
x <- c( rep( 0, n/2 ), rep( 1, n/2 ) )
t <- 1:n
mu <- b[1] + b[2] * x + b[3] * t
e <- arima.sim(model = list(ar = 0.5), n = n, sd = sdv)
y <- mu + e
plot(y)
n <- 50
b <- c(1, 5, 0.1)
sdv <- 1
x <- c( rep( 0, n/2 ), rep( 1, n/2 ) )
t <- 1:n
mu <- b[1] + b[2] * x + b[3] * t
e <- arima.sim(model = list(ar = 0.5), n = n, sd = sdv)
y <- mu + e
n <- 50
b <- c(1, 5, 0.1)
sdv <- 1
x <- c( rep( 0, n/2 ), rep( 1, n/2 ) )
t <- 1:n
mu <- b[1] + b[2] * x + b[3] * t
e <- arima.sim(model = list(ar = 0.5), n = n, sd = sdv)
y <- mu + e
plot(y)
n <- 50
b <- c(1, 2, 0.1)
sdv <- 1
x <- c( rep( 0, n/2 ), rep( 1, n/2 ) )
t <- 1:n
mu <- b[1] + b[2] * x + b[3] * t
e <- arima.sim(model = list(ar = 0.5), n = n, sd = sdv)
y <- mu + e
plot(y)
df <- data.frame(y, x, t)
#ARMA
ar1 <- arima(df$y, xreg = cbind(df$x, df$t), order = c(1, 0, 0))
n <- 50
b <- c(1, 2, 0.1)
sdv <- 1
x <- c( rep( 0, n/2 ), rep( 1, n/2 ) )
t <- 1:n
mu <- b[1] + b[2] * x + b[3] * t
e <- arima.sim(model = list(ar = 0.5), n = n, sd = sdv)
y <- mu + e
plot(y)
df <- data.frame(y, x, t)
#ARMA
ar1 <- arima(df$y, xreg = cbind(df$x, df$t), order = c(1, 0, 0))
ar1
prais_winsten(y ~ x + t, data = df)
library(prais)
n <- 50
b <- c(1, 2, 0.1)
sdv <- 1
x <- c( rep( 0, n/2 ), rep( 1, n/2 ) )
t <- 1:n
mu <- b[1] + b[2] * x + b[3] * t
e <- arima.sim(model = list(ar = 0.5), n = n, sd = sdv)
y <- mu + e
plot(y)
df <- data.frame(y, x, t)
#ARMA
arima(df$y, xreg = cbind(df$x, df$t), order = c(1, 0, 0))
prais_winsten(y ~ x + t, data = df)
library(prais)
set.seed(1066)
n <- 50
b <- c(1, 2, 0.1)
sdv <- 1
x <- c( rep( 0, n/2 ), rep( 1, n/2 ) )
t <- 1:n
mu <- b[1] + b[2] * x + b[3] * t
e <- arima.sim(model = list(ar = 0.5), n = n, sd = sdv)
y <- mu + e
plot(y)
df <- data.frame(y, x, t)
#ARMA
arima(df$y, xreg = cbind(df$x, df$t), order = c(1, 0, 0))
prais_winsten(y ~ x + t, data = df)
library(prais)
set.seed(1066)
n <- 50
b <- c(1, 2, 0.1)
sdv <- 1
x <- c( rep( 0, n/2 ), rep( 1, n/2 ) )
t <- 1:n
mu <- b[1] + b[2] * x + b[3] * t
e <- arima.sim(model = list(ar = 0.5), n = n, sd = sdv)
y <- mu + e
plot(y)
df <- data.frame(y, x, t)
#ARMA
arima(df$y, xreg = cbind(df$x, df$t), order = c(1, 0, 0))
prais_winsten(y ~ x + t, data = df)
?nlme
install.packages("nlme")
?nlme
library(prais)
library(nlme)
set.seed(1066)
n <- 50
b <- c(1, 2, 0.1)
sdv <- 1
x <- c( rep( 0, n/2 ), rep( 1, n/2 ) )
t <- 1:n
mu <- b[1] + b[2] * x + b[3] * t
e <- arima.sim(model = list(ar = 0.5), n = n, sd = sdv)
y <- mu + e
plot(y)
df <- data.frame(y, x, t)
#Models
arima(df$y, xreg = cbind(df$x, df$t), order = c(1, 0, 0))
prais_winsten(y ~ x + t, data = df)
?nlme
?gls
gls(y ~ x + t, data = df, correlation=corAR1())
?gls
library(prais)
library(nlme)
set.seed(1066)
n <- 50
b <- c(1, 2, 0.1)
sdv <- 1
x <- c( rep( 0, n/2 ), rep( 1, n/2 ) )
t <- 1:n
mu <- b[1] + b[2] * x + b[3] * t
e <- arima.sim(model = list(ar = 0.5), n = n, sd = sdv)
y <- mu + e
plot(y)
df <- data.frame(y, x, t)
#Models
arima(df$y, xreg = cbind(df$x, df$t), order = c(1, 0, 0))
prais_winsten(y ~ x + t, data = df)
gls(y ~ x + t, data = df, correlation=corAR1(), method = "ML")
gls(y ~ x + t, data = df, correlation=corAR1(), method = "REML")
reml <- gls(y ~ x + t, data = df, correlation=corAR1(), method = "REML")
anova.lme(reml)
summary(reml)
?arima
reml <- lme(y ~ x + t, data = df, correlation=corAR1(), method = "REML")
ln(0.578)
log(0.578)
-2.720^2
0.8^4
0.85^4
0.38*0.9
2527_2643
2527+2643
2527+2509
2474+2637
2474+2342
(2637-607)/2637
(229/105)/(262/148)
(220/76)/(204/128)
1.1*1588
12048*0.145
12048*0.145*1.11
12048*0.145*0.89
12048*0.89
13373*0.89
12048*1.11
* *analy_pneumo_ex*: analysis of pneumococcal vaccine example
* *data_pneumo_ex*: data used in pneumococcal vaccine example
* *est*: estimates and standard errors generated by *sim*
* *sim*: fits models to simulated data and outputs estimates and standard
errors to the file *est*
* *perform*: generates table and plots of performance results (bias, mean square error and coverage)
* *tabl_perform*: table of performance results generated by *perform*
* *fig_bias*: comparison of bias generated by *perform*
* *fig_mse*: comparison of mean square error generated by *perform*
* *fig_coverage*: comparison of coverage generated by *perform*
* *fig_coverage_ma*: coverage assuming MA model generated by *perform*
* *fig_pneumo_ex*: ITS analysis of pneumococcal example *perform*
#------------------------------------------------------------------------------#
# Evaluation of methods (Prais-Winsten, ARMA and Newey-West) in terms of bias, #
# mean square error and coverage using parameter estimates from simulated      #
# data. Performance measures and Monte Carlo error calculated using rsim       #
# package. Results outputted as a table (csv file) and as a matrix of plots.   #
#------------------------------------------------------------------------------#
library(tidyverse)
library(rsimsum)
# Plotting function
plotRes <- function(dat, y) {
ggplot(dat, aes(x = n, y = .data[[y]], color = method)) +
geom_line(size = 1.7) +
scale_color_manual(values = c("Linear Reg" = "#D47DC5",
"Prais Winsten" = "#B8643D",
"ARMA" = "#8CD9D2",
"Newey West" = "#37A447",
"MA(1)" = "#D1D075",
"MA(2)" = "#85C9D6",
"MA(3)" = "#000000")) +
theme_bw(base_size = 20) +
theme(legend.position = "top") +
labs(y = y) +
facet_wrap(~autocorr)
}
# Load data and reshape to long format
load("est.rda")
est_long <-
est %>%
as.data.frame() %>%
select(-b1, -b2, -b3, -sd) %>%
pivot_longer(-c("simno","scenario", "ma1", "ma2", "ma3", "n"),
names_to = c(".value", "method"),
names_pattern = "(.+)(.+)"
) %>%
rename(estimate = est) %>%
mutate(dfres = ifelse(method %in% 1:2, n-3, 1000))
# Add ACF
ARMAacf2 <- function(mavalues) {ARMAacf(ma = mavalues)[2:4]}
mavalues <- est_long[, c("ma1", "ma2", "ma3")]
rvalues <- t(apply(mavalues, 1, ARMAacf2))
colnames(rvalues) <- c("r1", "r2", "r3")
est_long <- cbind(est_long, rvalues)
# Use simsum to calculate performance of each method for each scenario
prfm <-
simsum(est_long, estvarname = "estimate", se = "se", df = "dfres",
true = -1, methodvar = "method", by = "scenario", ref = "1"
)
# Dataframe of results
dfRes <-
prfm$sum %>%
filter(stat == "bias" | stat == "mse" | stat == "cover")  %>%
pivot_wider(names_from = stat, values_from = c("est", "mcse")) %>%
select("scenario", everything())
param <-
est_long[, c( "scenario", "method", "r1", "r2", "r3", "n")] %>%
distinct() %>%
mutate(r1 = format(round(r1, 2))) %>%
mutate(r2 = format(round(r2, 2))) %>%
mutate(r3 = format(round(r3, 2))) %>%
unite("autocorr", "r1", "r2", "r3", sep = "|")  %>%
mutate(scenario = as.factor(scenario)) %>%
mutate(method = as.factor(method))
dfRes <-
param %>%
inner_join(dfRes, by = c("scenario", "method")) %>%
mutate(method = fct_recode(method,
"Linear Reg" = "1",
"Prais Winsten" = "2",
"ARMA" = "3",
"Newey West" = "4",
"MA(1)" = "5",
"MA(2)" = "6",
"MA(3)" = "7",
)
) %>%
rename(bias = est_bias) %>%
rename(coverage = est_cover) %>%
rename(mse = est_mse) %>%
mutate_if(is.numeric, ~round(.,3))
write.csv(dfRes, file = "tabl_perform.csv")
# Summarise results
dfRes %>%
mutate(lag1corr = as.numeric(str_sub(autocorr, 1, 4))) %>%
mutate(lb_bias = bias - qnorm(0.975) * mcse_bias) %>%
mutate(ub_bias = bias + qnorm(0.975) * mcse_bias) %>%
#filter(n<50) %>%
#filter(lag1corr>=0.6) %>%
group_by(method) %>%
summarise(
bias_mean = mean(bias),
coverage_mean = mean(coverage),
rmse_mean = mean(sqrt(mse)),
)
setwd("~/OneDrive - London School of Hygiene and Tropical Medicine/ITS_Autocorrelation")
#------------------------------------------------------------------------------#
# Evaluation of methods (Prais-Winsten, ARMA and Newey-West) in terms of bias, #
# mean square error and coverage using parameter estimates from simulated      #
# data. Performance measures and Monte Carlo error calculated using rsim       #
# package. Results outputted as a table (csv file) and as a matrix of plots.   #
#------------------------------------------------------------------------------#
library(tidyverse)
library(rsimsum)
# Plotting function
plotRes <- function(dat, y) {
ggplot(dat, aes(x = n, y = .data[[y]], color = method)) +
geom_line(size = 1.7) +
scale_color_manual(values = c("Linear Reg" = "#D47DC5",
"Prais Winsten" = "#B8643D",
"ARMA" = "#8CD9D2",
"Newey West" = "#37A447",
"MA(1)" = "#D1D075",
"MA(2)" = "#85C9D6",
"MA(3)" = "#000000")) +
theme_bw(base_size = 20) +
theme(legend.position = "top") +
labs(y = y) +
facet_wrap(~autocorr)
}
# Load data and reshape to long format
load("est.rda")
est_long <-
est %>%
as.data.frame() %>%
select(-b1, -b2, -b3, -sd) %>%
pivot_longer(-c("simno","scenario", "ma1", "ma2", "ma3", "n"),
names_to = c(".value", "method"),
names_pattern = "(.+)(.+)"
) %>%
rename(estimate = est) %>%
mutate(dfres = ifelse(method %in% 1:2, n-3, 1000))
# Add ACF
ARMAacf2 <- function(mavalues) {ARMAacf(ma = mavalues)[2:4]}
mavalues <- est_long[, c("ma1", "ma2", "ma3")]
rvalues <- t(apply(mavalues, 1, ARMAacf2))
colnames(rvalues) <- c("r1", "r2", "r3")
est_long <- cbind(est_long, rvalues)
# Use simsum to calculate performance of each method for each scenario
prfm <-
simsum(est_long, estvarname = "estimate", se = "se", df = "dfres",
true = -1, methodvar = "method", by = "scenario", ref = "1"
)
# Dataframe of results
dfRes <-
prfm$sum %>%
filter(stat == "bias" | stat == "mse" | stat == "cover")  %>%
pivot_wider(names_from = stat, values_from = c("est", "mcse")) %>%
select("scenario", everything())
param <-
est_long[, c( "scenario", "method", "r1", "r2", "r3", "n")] %>%
distinct() %>%
mutate(r1 = format(round(r1, 2))) %>%
mutate(r2 = format(round(r2, 2))) %>%
mutate(r3 = format(round(r3, 2))) %>%
unite("autocorr", "r1", "r2", "r3", sep = "|")  %>%
mutate(scenario = as.factor(scenario)) %>%
mutate(method = as.factor(method))
dfRes <-
param %>%
inner_join(dfRes, by = c("scenario", "method")) %>%
mutate(method = fct_recode(method,
"Linear Reg" = "1",
"Prais Winsten" = "2",
"ARMA" = "3",
"Newey West" = "4",
"MA(1)" = "5",
"MA(2)" = "6",
"MA(3)" = "7",
)
) %>%
rename(bias = est_bias) %>%
rename(coverage = est_cover) %>%
rename(mse = est_mse) %>%
mutate_if(is.numeric, ~round(.,3))
write.csv(dfRes, file = "tabl_perform.csv")
# Summarise results
dfRes %>%
mutate(lag1corr = as.numeric(str_sub(autocorr, 1, 4))) %>%
mutate(lb_bias = bias - qnorm(0.975) * mcse_bias) %>%
mutate(ub_bias = bias + qnorm(0.975) * mcse_bias) %>%
#filter(n<50) %>%
#filter(lag1corr>=0.6) %>%
group_by(method) %>%
summarise(
bias_mean = mean(bias),
coverage_mean = mean(coverage),
rmse_mean = mean(sqrt(mse)),
)
dfRes %>%
mutate(lag1corr = as.numeric(str_sub(autocorr, 1, 4))) %>%
mutate(lb_bias = bias - qnorm(0.975) * mcse_bias) %>%
mutate(ub_bias = bias + qnorm(0.975) * mcse_bias) %>%
#filter(n<50) %>%
filter(lag1corr>=0.6) %>%
group_by(method) %>%
summarise(
bias_mean = mean(bias),
coverage_mean = mean(coverage),
rmse_mean = mean(sqrt(mse)),
)
dfRes %>%
mutate(lag1corr = as.numeric(str_sub(autocorr, 1, 4))) %>%
mutate(lb_bias = bias - qnorm(0.975) * mcse_bias) %>%
mutate(ub_bias = bias + qnorm(0.975) * mcse_bias) %>%
#filter(n<50) %>%
filter(lag1corr<0.6) %>%
group_by(method) %>%
summarise(
bias_mean = mean(bias),
coverage_mean = mean(coverage),
rmse_mean = mean(sqrt(mse)),
)
dfRes %>%
mutate(lag1corr = as.numeric(str_sub(autocorr, 1, 4))) %>%
mutate(lb_bias = bias - qnorm(0.975) * mcse_bias) %>%
mutate(ub_bias = bias + qnorm(0.975) * mcse_bias) %>%
filter(n<50) %>%
#filter(lag1corr<0.6) %>%
group_by(method) %>%
summarise(
bias_mean = mean(bias),
coverage_mean = mean(coverage),
rmse_mean = mean(sqrt(mse)),
)
library(MASS)
library(prais)
library(sandwich)
library(forecast)
library(sfsmisc)
set.seed(1066)
# Function to generate data
# Input: vector of parameter values (ma1, ma2, ma3, n, b1, b2, b3, sd)
# Output: dataframe (y=ITS, x=intervention indicator, t=time)
genDat <- function(param) {
ma <- param[1:3]
n <- param[4]
b <- param[5:7]
sdv <- param[8]
x <- c( rep( 0, n/2 ), rep( 1, n/2 ) )
t <- 1:n
mu <- b[1] + b[2] * x + b[3] * t
e <- arima.sim(model = list(ma = ma), n = n, sd = sdv)
y <- mu + e
return(data.frame(y, x, t))
}
# Function to suppress output (Hadley Wickham)
quiet <- function(x) {
sink(tempfile())
on.exit(sink())
invisible(force(x))
}
# Function to fit models
# Input: dataframe (y, x, t)
# Output: dataframe of parameter estimates and standard errors
fitMods <- function(df) {
# Linear regression
lr <- lm(y ~ x + t, data = df)
est_lr <- coef(lr)["x"]
se_lr <- sqrt(vcov(lr)["x", "x"])
# Prais Winsten
pw <- quiet(prais_winsten(y ~ x + t, data = df))
est_pw <- coef(pw)["x"]
se_pw <- sqrt(vcovHC.prais(pw)["x", "x"])
# ARMA
aa <- auto.arima(df$y,
xreg = cbind(df$x, df$t),
stepwise = T,
d = 0,
D = 0,
ic = 'aicc',
seasonal = F)
converge_aa <- ifelse(sum(diag(vcov(aa)) <= 0) > 0, 0, 1)
est_aa <- ifelse(converge_aa == 1,
coef(aa)["xreg1"],
NaN
)
se_aa <- ifelse(converge_aa == 1,
sqrt(vcov(aa)["xreg1","xreg1"]),
NaN
)
# Newey West
se_nw <- sqrt(NeweyWest(lr,
lag = NULL,
prewhite = F,
adjust = T)["x", "x"]
)
# MA1
ma1 <- arima(df$y, xreg = cbind(df$x, df$t), order = c(0, 0, 1))
est_ma1 <- coef(ma1)["cbind(df$x, df$t)1"]
se_ma1 <- sqrt(vcov(ma1)["cbind(df$x, df$t)1", "cbind(df$x, df$t)1"])
# MA2
ma2 <- arima(df$y, xreg = cbind(df$x, df$t), order = c(0, 0, 2))
est_ma2 <- coef(ma2)["cbind(df$x, df$t)1"]
se_ma2 <- sqrt(vcov(ma2)["cbind(df$x, df$t)1", "cbind(df$x, df$t)1"])
# MA3
ma3 <- arima(df$y, xreg = cbind(df$x, df$t), order = c(0, 0, 3))
est_ma3 <- coef(ma3)["cbind(df$x, df$t)1"]
se_ma3 <- sqrt(vcov(ma3)["cbind(df$x, df$t)1", "cbind(df$x, df$t)1"])
# Combine and output estimates and standard errors
est <- c(est_lr, est_pw, est_aa, est_lr, est_ma1, est_ma2, est_ma3)
se <- c(se_lr, se_pw, se_aa, se_nw, se_ma1, se_ma2, se_ma3)
cbind(est, se)
}
# Matrix of parameter values (ma1-ma3, n, b1-b3, sd)
# Each row represents a different scenario
nma <- 20
ma1values <- sort(runif(nma, min = 0, max = 1))
ma2values <- runif(nma, min = 0, max = ma1values)
ma3values <- runif(nma, min = 0, max = ma2values)
nvalues  <- c(20, 50, 100, 300)
nn <- length(nvalues)
b1 <- 4
b2 <- -1
b3 <- -1
sdv <- 1
param <- cbind(
rep(ma1values, each = nn),
rep(ma2values, each = nn),
rep(ma3values, each = nn),
rep(nvalues, nma),
rep(b1, nma * nn),
rep(b2, nma * nn),
rep(b3, nma * nn),
rep(sdv, nma * nn)
)
colnames(param) <- c("ma1", "ma2", "ma3","n", "b1", "b2", "b3", "sd")
param[ , "b3"] <-  param[ , "b3"] / param[ , "n"]
param
